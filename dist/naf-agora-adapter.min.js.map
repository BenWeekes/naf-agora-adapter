{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","AgoraRtcAdapter","constructor","easyrtc","console","log","this","window","app","room","userid","appid","mediaStreams","remoteClients","pendingMediaRequests","Map","enableVideo","enableAudio","localTracks","videoTrack","audioTrack","token","clientId","uid","vbg","showLocal","virtualBackgroundInstance","serverTimeRequests","timeOffsets","avgTimeOffset","agoraClient","AgoraRTC","loadModule","SegPlugin","setPeerOpenListener","clientConnection","getPeerConnectionByUserId","setPeerClosedListener","setServerUrl","url","setSocketUrl","setApp","appName","json","replace","obj","JSON","parse","joinRoom","setWebRtcOptions","options","enableDataChannels","datachannel","video","audio","enableVideoReceive","enableAudioReceive","setServerConnectListeners","successListener","failureListener","connectSuccess","connectFailure","setRoomOccupantListener","occupantListener","roomName","occupants","primary","setDataChannelListeners","openListener","closedListener","messageListener","setDataChannelOpenListener","setDataChannelCloseListener","setPeerListener","updateTimeOffset","clientSentTime","Date","now","fetch","document","location","href","method","cache","then","res","serverReceivedTime","headers","getTime","precision","clientReceivedTime","timeOffset","push","reduce","acc","offset","length","setTimeout","connect","Promise","all","resolve","reject","_connect","_","_myRoomJoinTime","_getRoomJoinTime","connectAgora","catch","shouldStartConnectionTo","client","roomJoinTime","startStreamConnection","caller","media","NAF","write","errorCode","errorText","error","wasAccepted","closeStreamConnection","hangup","sendData","dataType","data","sendDataGuaranteed","sendDataWS","broadcastData","roomOccupants","getRoomOccupantsAsMap","roomOccupant","myEasyrtcid","broadcastDataGuaranteed","destination","targetRoom","getConnectStatus","status","IS_CONNECTED","adapters","NOT_CONNECTED","CONNECTING","getMediaStream","streamName","has","audioPromise","e","warn","promise","videoPromise","set","streamPromise","setMediaStream","stream","clientMediaStreams","audioTracks","getAudioTracks","audioStream","MediaStream","forEach","track","addTrack","videoTracks","getVideoTracks","videoStream","addLocalMediaStream","id","register3rdPartyLocalMediaStream","keys","addStreamToCall","removeLocalMediaStream","closeLocalMediaStream","enableMicrophone","enabled","enableCamera","disconnect","user","mediaType","handleUserUnpublished","that","createClient","codec","on","async","subscribe","_mediaStreamTrack","join","createMicrophoneAudioTrack","createCameraVideoTrack","play","publish","values","imgElement","createElement","onload","inject","setOptions","enable","background","src","myRoomId","getServerTime","register"],"mappings":"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","file":"naf-agora-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\nclass AgoraRtcAdapter {\n\n  constructor(easyrtc) {\n     console.log(\"BW73 constructor \", easyrtc);\n\n    this.easyrtc = easyrtc || window.easyrtc;\n    this.app = \"default\";\n    this.room = \"default\";\n    this.userid=0;\n    this.appid=null;\n\n    this.mediaStreams = {};\n    this.remoteClients = {};\n    this.pendingMediaRequests = new Map();\n\n    this.enableVideo=false;\n    this.enableAudio=false;\n\n    this.localTracks = { videoTrack: null, audioTrack: null };\n    this.token=null;\n    this.clientId=null;\n    this.uid=null;\n    this.vbg=false;\n    this.showLocal=false;\n    this.virtualBackgroundInstance=null;\n\t \n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n    this.agoraClient=null;\n    AgoraRTC.loadModule(SegPlugin, {});\n\n    this.easyrtc.setPeerOpenListener((clientId) => {\n      const clientConnection = this.easyrtc.getPeerConnectionByUserId(clientId);\n      this.remoteClients[clientId] = clientConnection;\n    });\n\n    this.easyrtc.setPeerClosedListener((clientId) => {\n      delete this.remoteClients[clientId];\n    });\n  }\n\n  setServerUrl(url) {\n     console.log(\"BW73 setServerUrl \", url);\n    this.easyrtc.setSocketUrl(url);\n  }\n\n  setApp(appName) {\n     console.log(\"BW73 setApp \", appName);\n    this.app = appName;\n    this.appid = appName;\n  }\n\n  async setRoom(json) {\n    json=json.replace(/'/g, '\"');\n    const obj = JSON.parse(json);\n    this.room = obj.name;\n\n    if (obj.vbg) {\n  \t  this.vbg=obj.vbg;\n    }\n    if (obj.showLocal) {\n  \t  this.showLocal=obj.showLocal;\n    }\n    this.easyrtc.joinRoom(this.room, null);\n  }\n\n  // options: { datachannel: bool, audio: bool, video: bool }\n  setWebRtcOptions(options) {\n     console.log(\"BW73 setWebRtcOptions \", options);\n    // this.easyrtc.enableDebug(true);\n    this.easyrtc.enableDataChannels(options.datachannel);\n\n    // using Agora\n    this.enableVideo=options.video;\n    this.enableAudio=options.audio;\n\t\n    // not easyrtc\n    this.easyrtc.enableVideo(false);\n    this.easyrtc.enableAudio(false);\n    this.easyrtc.enableVideoReceive(false);\n    this.easyrtc.enableAudioReceive(false);\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n     console.log(\"BW73 setServerConnectListeners \", successListener, failureListener);\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n     console.log(\"BW73 setRoomOccupantListener \", occupantListener);\n\t  \n    this.easyrtc.setRoomOccupantListener(function(\n      roomName,\n      occupants,\n      primary\n    ) {\n      occupantListener(occupants);\n    });\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n     console.log(\"BW73 setDataChannelListeners  \", openListener, closedListener, messageListener);\n    this.easyrtc.setDataChannelOpenListener(openListener);\n    this.easyrtc.setDataChannelCloseListener(closedListener);\n    this.easyrtc.setPeerListener(messageListener);\n  }\n\n  updateTimeOffset() {\n     console.log(\"BW73 updateTimeOffset \");\n    const clientSentTime = Date.now() + this.avgTimeOffset;\n\n    return fetch(document.location.href, { method: \"HEAD\", cache: \"no-cache\" })\n      .then(res => {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + (precision / 2);\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + ((clientReceivedTime - clientSentTime) / 2);\n        var timeOffset = serverTime - clientReceivedTime;\n\n        this.serverTimeRequests++;\n\n        if (this.serverTimeRequests <= 10) {\n          this.timeOffsets.push(timeOffset);\n        } else {\n          this.timeOffsets[this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        this.avgTimeOffset = this.timeOffsets.reduce((acc, offset) => acc += offset, 0) / this.timeOffsets.length;\n\n        if (this.serverTimeRequests > 10) {\n          setTimeout(() => this.updateTimeOffset(), 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          this.updateTimeOffset();\n        }\n      });\n  }\n\n  connect() {\n     console.log(\"BW73 connect \");\n    Promise.all([\n      this.updateTimeOffset(),\n      new Promise((resolve, reject) => {\n        this._connect(resolve, reject);\n      })\n    ]).then(([_, clientId]) => {\n     console.log(\"BW73 connected \"+clientId);\n      this.clientId=clientId;\n      this._myRoomJoinTime = this._getRoomJoinTime(clientId);\n      this.connectAgora();\n      this.connectSuccess(clientId);\n    }).catch(this.connectFailure);\n  }\n\n  shouldStartConnectionTo(client) {\n    return this._myRoomJoinTime <= client.roomJoinTime;\n  }\n\n  startStreamConnection(clientId) {\n    console.log(\"BW73 startStreamConnection \",  clientId);\n    this.easyrtc.call(\n      clientId,\n      function(caller, media) {\n        if (media === \"datachannel\") {\n          NAF.log.write(\"Successfully started datachannel to \", caller);\n        }\n      },\n      function(errorCode, errorText) {\n        NAF.log.error(errorCode, errorText);\n      },\n      function(wasAccepted) {\n        // console.log(\"was accepted=\" + wasAccepted);\n      }\n    );\n  }\n\n  closeStreamConnection(clientId) {\n     console.log(\"BW73 closeStreamConnection \", clientId);\n    this.easyrtc.hangup(clientId);\n  }\n\n  sendData(clientId, dataType, data) {\n     console.log(\"BW73 sendData \", clientId, dataType, data);\n    // send via webrtc otherwise fallback to websockets\n    this.easyrtc.sendData(clientId, dataType, data);\n  }\n\n  sendDataGuaranteed(clientId, dataType, data) {\n     console.log(\"BW73 sendDataGuaranteed \", clientId,  dataType, data);\n    this.easyrtc.sendDataWS(clientId, dataType, data);\n  }\n\n  broadcastData(dataType, data) {\n     console.log(\"BW73 broadcastData \", dataType, data);\n    var roomOccupants = this.easyrtc.getRoomOccupantsAsMap(this.room);\n\n    // Iterate over the keys of the easyrtc room occupants map.\n    // getRoomOccupantsAsArray uses Object.keys which allocates memory.\n    for (var roomOccupant in roomOccupants) {\n      if (\n        roomOccupants[roomOccupant] &&\n        roomOccupant !== this.easyrtc.myEasyrtcid\n      ) {\n        // send via webrtc otherwise fallback to websockets\n        this.easyrtc.sendData(roomOccupant, dataType, data);\n      }\n    }\n  }\n\n  broadcastDataGuaranteed(dataType, data) {\n     console.log(\"BW73 broadcastDataGuaranteed \", dataType, data);\n    var destination = { targetRoom: this.room };\n    this.easyrtc.sendDataWS(destination, dataType, data);\n  }\n\n  getConnectStatus(clientId) {\n    console.log(\"BW73 getConnectStatus \", clientId);\n    var status = this.easyrtc.getConnectStatus(clientId);\n\n    if (status == this.easyrtc.IS_CONNECTED) {\n      return NAF.adapters.IS_CONNECTED;\n    } else if (status == this.easyrtc.NOT_CONNECTED) {\n      return NAF.adapters.NOT_CONNECTED;\n    } else {\n      return NAF.adapters.CONNECTING;\n    }\n  }\n\n  getMediaStream(clientId, streamName = \"audio\") {\n\n     console.log(\"BW73 getMediaStream \", clientId, streamName);\n\n    if (this.mediaStreams[clientId] && this.mediaStreams[clientId][streamName]) {\n      NAF.log.write(`Already had ${streamName} for ${clientId}`);\n      return Promise.resolve(this.mediaStreams[clientId][streamName]);\n    } else {\n      NAF.log.write(`Waiting on ${streamName} for ${clientId}`);\n\n      // Create initial pendingMediaRequests with audio|video alias\n      if (!this.pendingMediaRequests.has(clientId)) {\n        const pendingMediaRequests = {};\n\n        const audioPromise = new Promise((resolve, reject) => {\n          pendingMediaRequests.audio = { resolve, reject };\n        }).catch(e => NAF.log.warn(`${clientId} getMediaStream Audio Error`, e));\n        pendingMediaRequests.audio.promise = audioPromise;\n\n        const videoPromise = new Promise((resolve, reject) => {\n          pendingMediaRequests.video = { resolve, reject };\n        }).catch(e => NAF.log.warn(`${clientId} getMediaStream Video Error`, e));\n        pendingMediaRequests.video.promise = videoPromise;\n\n        this.pendingMediaRequests.set(clientId, pendingMediaRequests);\n      }\n\n      const pendingMediaRequests = this.pendingMediaRequests.get(clientId);\n\n      // Create initial pendingMediaRequests with streamName\n      if (!pendingMediaRequests[streamName]) {\n        const streamPromise = new Promise((resolve, reject) => {\n          pendingMediaRequests[streamName] = { resolve, reject };\n        }).catch(e => NAF.log.warn(`${clientId} getMediaStream \"${streamName}\" Error`, e))\n        pendingMediaRequests[streamName].promise = streamPromise;\n      }\n\n      return this.pendingMediaRequests.get(clientId)[streamName].promise;\n    }\n  }\n\n  setMediaStream(clientId, stream, streamName) {\n    console.log(\"BW73 setMediaStream \", clientId, stream, streamName);\n    const pendingMediaRequests = this.pendingMediaRequests.get(clientId); // return undefined if there is no entry in the Map\n    const clientMediaStreams = this.mediaStreams[clientId] = this.mediaStreams[clientId] || {};\n\n    if (streamName === 'default') {\n      // Safari doesn't like it when you use a mixed media stream where one of the tracks is inactive, so we\n      // split the tracks into two streams.\n      // Add mediaStreams audio streamName alias\n      const audioTracks = stream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        const audioStream = new MediaStream();\n        try {\n          audioTracks.forEach(track => audioStream.addTrack(track));\n          clientMediaStreams.audio = audioStream;\n        } catch(e) {\n          NAF.log.warn(`${clientId} setMediaStream \"audio\" alias Error`, e);\n        }\n\n        // Resolve the promise for the user's media stream audio alias if it exists.\n        if (pendingMediaRequests) pendingMediaRequests.audio.resolve(audioStream);\n      }\n\n      // Add mediaStreams video streamName alias\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length > 0) {\n        const videoStream = new MediaStream();\n        try {\n          videoTracks.forEach(track => videoStream.addTrack(track));\n          clientMediaStreams.video = videoStream;\n        } catch(e) {\n          NAF.log.warn(`${clientId} setMediaStream \"video\" alias Error`, e);\n        }\n\n        // Resolve the promise for the user's media stream video alias if it exists.\n        if (pendingMediaRequests) pendingMediaRequests.video.resolve(videoStream);\n      }\n    } else {\n      clientMediaStreams[streamName] = stream;\n\n      // Resolve the promise for the user's media stream by StreamName if it exists.\n      if (pendingMediaRequests && pendingMediaRequests[streamName]) {\n        pendingMediaRequests[streamName].resolve(stream);\n      }\n    }\n  }\n\n  addLocalMediaStream(stream, streamName) {\n     console.log(\"BW73 addLocalMediaStream \", stream, streamName);\n    const easyrtc = this.easyrtc;\n    streamName = streamName || stream.id;\n    this.setMediaStream(\"local\", stream, streamName);\n    easyrtc.register3rdPartyLocalMediaStream(stream, streamName);\n\n    // Add local stream to existing connections\n    Object.keys(this.remoteClients).forEach((clientId) => {\n      if (easyrtc.getConnectStatus(clientId) !== easyrtc.NOT_CONNECTED) {\n        easyrtc.addStreamToCall(clientId, streamName);\n      }\n    });\n  }\n\n  removeLocalMediaStream(streamName) \n\t{\n     console.log(\"BW73 removeLocalMediaStream \", streamName);\n    this.easyrtc.closeLocalMediaStream(streamName);\n    delete this.mediaStreams[\"local\"][streamName];\n  }\n\n  enableMicrophone(enabled) {\n     console.log(\"BW73 enableMicrophone \", enabled);\n    this.easyrtc.enableMicrophone(enabled);\n  }\n\n  enableCamera(enabled) {\n     console.log(\"BW73 enableCamera \", enabled);\n    this.easyrtc.enableCamera(enabled);\n  }\n\n  disconnect() {\n     console.log(\"BW73 disconnect \");\n    this.easyrtc.disconnect();\n  }\n\nasync handleUserPublished(user, mediaType) {\n\n\n}\n\n handleUserUnpublished(user, mediaType) {\n    console.log(\"BW73 handleUserUnPublished \");\n}\n\nasync connectAgora() {\n  // Add an event listener to play remote tracks when remote user publishes.\n  var that=this;\n\n  if (this.enableVideo || this.enableAudio) {\n    this.agoraClient= AgoraRTC.createClient({mode: \"rtc\", codec: \"vp8\"});\n  } else {\n    this.agoraClient= AgoraRTC.createClient({mode: \"live\", codec: \"vp8\"});\n  }\n\n  this.agoraClient.on(\"user-published\", async (user, mediaType) => {\n\n   let clientId = user.uid;\n   console.log(\"BW73 handleUserPublished \"+clientId+\" \"+mediaType,that.agoraClient);\n   await that.agoraClient.subscribe(user, mediaType);\n   console.log(\"BW73 handleUserPublished2 \"+clientId+\" \"+that.agoraClient);\n\n   const pendingMediaRequests = that.pendingMediaRequests.get(clientId); \n   const clientMediaStreams = that.mediaStreams[clientId] = that.mediaStreams[clientId] || {};\n\n  if (mediaType === 'audio') {\n     const audioStream = new MediaStream();\n     console.log(\"user.audioTrack \",user.audioTrack._mediaStreamTrack);\n     audioStream.addTrack(user.audioTrack._mediaStreamTrack);\n     clientMediaStreams.audio = audioStream;\n     if (pendingMediaRequests) pendingMediaRequests.audio.resolve(audioStream);\n  } \n\n  if (mediaType === 'video') {\n     const videoStream = new MediaStream();\n     console.log(\"user.videoTrack \",user.videoTrack._mediaStreamTrack);\n     videoStream.addTrack(user.videoTrack._mediaStreamTrack);\n     clientMediaStreams.video = videoStream;\n     if (pendingMediaRequests) pendingMediaRequests.video.resolve(videoStream);\n\t  //user.videoTrack\n  } \n\n});\n\n  this.agoraClient.on(\"user-unpublished\", that.handleUserUnpublished);\n\n  console.log(\"connect agora \");\n  // Join a channel and create local tracks. Best practice is to use Promise.all and run them concurrently.\n// o\n\n\n\n  if (this.enableVideo && this.enableAudio) {\n     [ this.userid, this.localTracks.audioTrack, this.localTracks.videoTrack ] = await Promise.all([\n       // Join the channel.\n       this.agoraClient.join(this.appid, this.room, this.token || null, this.clientId || null),\n       // Create tracks to the local microphone and camera.\n       AgoraRTC.createMicrophoneAudioTrack(),\n       AgoraRTC.createCameraVideoTrack(\"360p_4\")\n     ]);\n  } else if (this.enableVideo) {\n     [ this.userid, this.localTracks.videoTrack ] = await Promise.all([\n       // Join the channel.\n       this.agoraClient.join(this.appid, this.room, this.token || null, this.clientId || null),\n       AgoraRTC.createCameraVideoTrack(\"360p_4\")\n     ]);\n  } else if (this.enableAudio) {\n     [ this.userid, this.localTracks.audioTrack ] = await Promise.all([\n       // Join the channel.\n       this.agoraClient.join(this.appid, this.room, this.token || null, this.clientId || null),\n       AgoraRTC.createMicrophoneAudioTrack()\n     ]);\n  } else  {\n\t  this.userid=await this.agoraClient.join(this.appid, this.room, this.token || null, this.clientId || null);\n  }\n\n    \tif (this.enableVideo && this.showLocal) {\n\t\tthis.localTracks.videoTrack.play(\"local-player\");\n\t}\n\n  if (this.enableVideo || this.enableAudio) {\n\n   await this.agoraClient.publish(Object.values(this.localTracks));\n   console.log(\"publish success\");\n\n  // Publish the local video and audio tracks to the channel.\n  if (this.enableVideo &&  this.vbg &&  this.localTracks.videoTrack) {\n      const imgElement = document.createElement('img');\n      imgElement.onload = async() => {\n        if (!this.virtualBackgroundInstance) {\n\t  console.log(\"SEG INIT \",this.localTracks.videoTrack);\n          this.virtualBackgroundInstance = await SegPlugin.inject(this.localTracks.videoTrack, \"/assets/wasms\").catch(console.error);\n\t  console.log(\"SEG INITED\");\n        }\n        this.virtualBackgroundInstance.setOptions({enable: true, background: imgElement});\n      }\n     imgElement.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAAD0lEQVR4XmNg+M+AQDg5AOk9C/VkomzYAAAAAElFTkSuQmCC';\n  } \n  }\n}\n\n  /**\n   * Privates\n   */\n\n  async _connect(connectSuccess, connectFailure) {\n    var that = this;\n\n  await that.easyrtc.connect(that.app, connectSuccess, connectFailure);\n\n\n \t/*\n\n    this.easyrtc.setStreamAcceptor(this.setMediaStream.bind(this));\n\n    this.easyrtc.setOnStreamClosed(function(clientId, stream, streamName) {\n      delete this.mediaStreams[clientId][streamName];\n    });\n\n    if (that.easyrtc.audioEnabled || that.easyrtc.videoEnabled) {\n      navigator.mediaDevices.getUserMedia({\n        video: that.easyrtc.videoEnabled,\n        audio: that.easyrtc.audioEnabled\n      }).then(\n        function(stream) {\n          that.addLocalMediaStream(stream, \"default\");\n          that.easyrtc.connect(that.app, connectSuccess, connectFailure);\n        },\n        function(errorCode, errmesg) {\n          NAF.log.error(errorCode, errmesg);\n        }\n      );\n    } else {\n      that.easyrtc.connect(that.app, connectSuccess, connectFailure);\n    }\n    */\n  }\n\n  _getRoomJoinTime(clientId) {\n    var myRoomId = this.room; //NAF.room;\n    var joinTime = this.easyrtc.getRoomOccupantsAsMap(myRoomId)[clientId]\n      .roomJoinTime;\n    return joinTime;\n  }\n\n  getServerTime() {\n    return Date.now() + this.avgTimeOffset;\n  }\n}\n\nNAF.adapters.register(\"agorartc\", AgoraRtcAdapter);\n\nmodule.exports = AgoraRtcAdapter;\n"],"sourceRoot":""}